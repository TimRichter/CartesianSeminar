* Code scratchpad for Cartesian seminar October 2022 
We read Gibbons "A pointless derivation of radix sort"
** Session October 18th
*** pointfree (pointless) calculation:
defined in the abstract as calculations on the level of function composition
instead of at the level of function application
*** Nicola: give an example for a "calculation"

#+begin_src agda2
module Gibbons where

data ℕ : Set where
  Zero : ℕ
  Succ : ℕ → ℕ



{-# BUILTIN NATURAL ℕ #-}

id : ℕ → ℕ
id n = n   -- no parentheses around function arguments!

infixr 10 _+_
infixr 20 _*_

_+_ : ℕ → ℕ → ℕ
Zero + b = b
Succ a + b = Succ (a + b)

_*_ : ℕ → ℕ → ℕ   
Zero * b = Zero
Succ a * b = b + a * b

-- Note! : function application by juxtaposition
-- (the argument isn't put in parentheses) 
double : ℕ → ℕ
double n = 2 * n

quadruple : ℕ → ℕ
quadruple n = 4 * n

quadruple' : ℕ → ℕ
quadruple' n = double (double n)

#+end_src agda2
*** TODO Explain difference between A → (B → C), (A → B) → C, A×B → C !
** Session October 25th
*** complete the example for a pointfree function definition:
#+begin_src agda2

-- goal: define quadruple "pointfree", i.e. without mentioning the argument,
--       this would be
--  quadruple = double ∘ double
--       where the ∘ denotes function composition.
--       So let's define this:

infix 10 _∘_

_∘_ : {A B C : Set} → (B → C) → (A → B) → (A → C)
(g ∘ f) a = g (f a)

quadruple'' : ℕ → ℕ
quadruple'' = double ∘ double

#+end_src agda2
*** talked about equivalence of types:
two sets X and Y are equivalent if there is a Bijektion f : X → Y
f bijective means: f is injective and f is surjective
*** alternative definition of equivalence: X and Y are equivalent if
∃ f : X → Y ∃ g : Y → X . g ∘ f = id_X  ∧ f ∘ g = id_Y
*** we can do this for the example  A × B → C  is equivalent to A → B → C
#+begin_src agda2

infixr 30 _×_
infixr 30 _,_

record _×_ (A B : Set) : Set where
   constructor _,_
   field
     fst : A
     snd : B

-- "Currying", named after Haskell Curry, a mathematician and
-- philosopher of the 20th century

curry : {A B C : Set} → (A × B → C) → (A → B → C)
curry h a b = h (a , b)

uncurry : {A B C : Set} → (A → B → C) → (A × B → C)
uncurry h (a , b) = h a b

infix 25 _==_

data _==_ {A : Set} (a : A) : A → Set where
  refl : a == a

-- equational reasoning notation
{-# BUILTIN EQUALITY _==_ #-}

trans : ∀ {A : Set} {x y z : A} → x == y → y == z → x == z
trans refl refl = refl

symm : ∀ {A : Set} {x y : A} → x == y → y == x
symm refl = refl

_QED : ∀ {A : Set} (x : A) → x == x
x QED = refl

infixr 10 _=⟨_⟩_   -- emacs agda-mode: \langle \rangle
infixr 10 _=⟨⟩_

_=⟨_⟩_ : ∀ {A : Set} (x : A) {y z : A} →
         x == y → y == z → x == z
x =⟨ p ⟩ q = trans p q

_=⟨⟩_ : ∀ {A : Set} (x : A) {y : A} →
        x == y → x == y
x =⟨⟩ q = x =⟨ refl ⟩ q

cong : ∀ {A : Set} {B : Set} {x y : A} →
       (f : A → B) → x == y → f x == f y
cong f refl = refl


id1 : ∀ {A B C : Set} (h : A × B → C) (p : A × B) →
      (uncurry ∘ curry) h p == h p
id1 h p = refl 

id1' : {A B C : Set} → (h : A × B → C) →
      (uncurry ∘ curry) h == h
id1' h = refl 

id2 : {A B C : Set} → (h : A → B → C) →
      (a : A) → (b : B) → (curry ∘ uncurry) h a b == h a b
id2 h a b = 
         (curry ∘ uncurry) h a b
           =⟨ refl {- Def. of "∘" -} ⟩
         (curry (uncurry h)) a b
           =⟨ refl {- Def. of "curry" -} ⟩
         (uncurry h) (a , b)
           =⟨ refl {- Def. of "uncurry" -} ⟩
         h a b
           QED

#+end_src agda2
*** DONE (Homework): show uncurry ∘ curry = id  and  curry ∘ uncurry = id 
** Session November 1st
*** did homework of last week, see above
*** read page 1
*** discussed examples of orderings that fit the description
**** words in a dictionary:
the list is the infinite list of functions String → Char
[pick 1st char, pick 2nd char, ...]
**** contacts in a smartphone or phonebook 
the list contains the projection functions to separate fields
(name, surname, phone number, birthday etc.) of a contact
- strictly speaking isn't an instance of the given abstraction,
  because fields are of different types...
*** on with the agda-implementation
#+begin_src agda2

infixr 20 _∷_                   -- input ∷ by typing \::

data List (A : Set) : Set where
        [] : List A
        _∷_ : A → List A → List A

length : {A : Set} → List A → ℕ
length [] = 0
length ( a ∷ as ) = length as + 1

data Bool : Set where
  true : Bool
  false : Bool

infixl 27 _&&_
infixl 26 _||_

_&&_ _||_ : Bool → Bool → Bool

true  && b = b
false && _ = false

true  || _ = true
false || b = b

ordered : {A B : Set} → (List (A → B)) → A → A → Bool
ordered = {!!}

#+end_src agda2
*** Homework:
**** read rest of §1
**** complete the implementation of List and Bool
** Session November 8th
*** discussed data type definitions Bool and List - see above
*** implemented length as an exercise - see above
*** discussed specifications vs. implementations
**** in the case of length the specification can immediately be used as a definition
**** in the case  e.g. of the square root function  with a specification
f : Real⁺ → Real
s.t. ∀ x : Real⁺,  (f x) * (f x) == x

it is more difficult:
+ what exactly is meant by "=="?
+ is the specification complete?
  -> Since for x /= 0 there are two choices for (f x)
     the above does not specify the function f uniquely! 
+ is the specification implementable?
+ if it is, how can f x actually be computed?

**** on with the paper

#+begin_src agda2

data Tree (A : Set) : Set where
  Leaf : A → Tree A
  Node : List (Tree A)  → Tree A

mkTree : {A B : Set} → List (A → B) → List A → Tree (List A)
mkTree []       as = Leaf as
mkTree (d ∷ ds) as = Node {!!}  -- t.b.c....


-- trying to dissect the rhs of ptn:  [ filter ((m==).d) xs | m <- rng ]
--  (m==).d  is
--   (m ===_) ∘ d  : A → Bool
{-
     ((m ===_) ∘ d) a
        ={Def. of ∘}
     ((m ===_) (d a))
        ={Notation}
     (m === d a)
-}
--  where _===_ : B → B → Bool

--filter : {A : Set} → (A → Bool) → List A → List A

#+end_src agda2






