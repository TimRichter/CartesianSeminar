* Code scratchpad for Cartesian seminar October 2022 
We read Gibbons "A pointless derivation of radix sort"
** Session October 18th
*** pointfree (pointless) calculation:
defined in the abstract as calculations on the level of function composition
instead of at the level of function application
*** Nicola: give an example for a "calculation"

#+begin_src agda2
module Gibbons where

data ℕ : Set where
  Zero : ℕ
  Succ : ℕ → ℕ



{-# BUILTIN NATURAL ℕ #-}

idℕ : ℕ → ℕ
idℕ n = n   -- no parentheses around function arguments!

infixr 10 _+_
infixr 20 _*_

_+_ : ℕ → ℕ → ℕ
Zero + b = b
Succ a + b = Succ (a + b)

_*_ : ℕ → ℕ → ℕ   
Zero * b = Zero
Succ a * b = b + a * b

-- Note! : function application by juxtaposition
-- (the argument isn't put in parentheses) 
double : ℕ → ℕ
double n = 2 * n

quadruple : ℕ → ℕ
quadruple n = 4 * n

quadruple' : ℕ → ℕ
quadruple' n = double (double n)

#+end_src agda2
*** TODO Explain difference between A → (B → C), (A → B) → C, A×B → C !
** Session October 25th
*** complete the example for a pointfree function definition:
#+begin_src agda2

-- goal: define quadruple "pointfree", i.e. without mentioning the argument,
--       this would be
--  quadruple = double ∘ double
--       where the ∘ denotes function composition.
--       So let's define this:

infix 10 _∘_

_∘_ : {A B C : Set} → (B → C) → (A → B) → (A → C)
(g ∘ f) a = g (f a)

quadruple'' : ℕ → ℕ
quadruple'' = double ∘ double

#+end_src agda2
*** talked about equivalence of types:
two sets X and Y are equivalent if there is a Bijektion f : X → Y
f bijective means: f is injective and f is surjective
*** alternative definition of equivalence: X and Y are equivalent if
∃ f : X → Y ∃ g : Y → X . g ∘ f = id_X  ∧ f ∘ g = id_Y
*** we can do this for the example  A × B → C  is equivalent to A → B → C
#+begin_src agda2

infixr 30 _×_
infixr 30 _,_

record _×_ (A B : Set) : Set where
   constructor _,_
   field
     fst : A
     snd : B

-- "Currying", named after Haskell Curry, a mathematician and
-- philosopher of the 20th century

curry : {A B C : Set} → (A × B → C) → (A → B → C)
curry h a b = h (a , b)

uncurry : {A B C : Set} → (A → B → C) → (A × B → C)
uncurry h (a , b) = h a b

infix 25 _==_

data _==_ {A : Set} (a : A) : A → Set where
  refl : a == a

-- equational reasoning notation
{-# BUILTIN EQUALITY _==_ #-}

trans : ∀ {A : Set} {x y z : A} → x == y → y == z → x == z
trans refl refl = refl

symm : ∀ {A : Set} {x y : A} → x == y → y == x
symm refl = refl

_QED : ∀ {A : Set} (x : A) → x == x
x QED = refl

infixr 10 _=⟨_⟩_   -- emacs agda-mode: \langle \rangle
infixr 10 _=⟨⟩_

_=⟨_⟩_ : ∀ {A : Set} (x : A) {y z : A} →
         x == y → y == z → x == z
x =⟨ p ⟩ q = trans p q

_=⟨⟩_ : ∀ {A : Set} (x : A) {y : A} →
        x == y → x == y
x =⟨⟩ q = x =⟨ refl ⟩ q

cong : ∀ {A : Set} {B : Set} {x y : A} →
       (f : A → B) → x == y → f x == f y
cong f refl = refl


id1 : ∀ {A B C : Set} (h : A × B → C) (p : A × B) →
      (uncurry ∘ curry) h p == h p
id1 h p = refl 

id1' : {A B C : Set} → (h : A × B → C) →
      (uncurry ∘ curry) h == h
id1' h = refl 

id2 : {A B C : Set} → (h : A → B → C) →
      (a : A) → (b : B) → (curry ∘ uncurry) h a b == h a b
id2 h a b = 
         (curry ∘ uncurry) h a b
           =⟨ refl {- Def. of "∘" -} ⟩
         (curry (uncurry h)) a b
           =⟨ refl {- Def. of "curry" -} ⟩
         (uncurry h) (a , b)
           =⟨ refl {- Def. of "uncurry" -} ⟩
         h a b
           QED

#+end_src agda2
*** DONE (Homework): show uncurry ∘ curry = id  and  curry ∘ uncurry = id 
** Session November 1st
*** did homework of last week, see above
*** read page 1
*** discussed examples of orderings that fit the description
**** words in a dictionary:
the list is the infinite list of functions String → Char
[pick 1st char, pick 2nd char, ...]
**** contacts in a smartphone or phonebook 
the list contains the projection functions to separate fields
(name, surname, phone number, birthday etc.) of a contact
- strictly speaking isn't an instance of the given abstraction,
  because fields are of different types...
*** on with the agda-implementation
#+begin_src agda2

infixr 20 _∷_                   -- input ∷ by typing \::

data List (A : Set) : Set where
        [] : List A
        _∷_ : A → List A → List A

-- List syntax (from https://doisinkidney.com/posts/2019-04-20-ListSyntax.html)

module Instance where
  record ListSyntax (A B : Set) : Set where
    field [_] : B → List A

  open ListSyntax ⦃ ... ⦄ public

  instance
    cons : ∀ {A B : Set} ⦃ _ : ListSyntax A B ⦄
         →  ListSyntax A (A × B)
    [_] ⦃ cons ⦄ (x , xs) = x ∷ [ xs ]

  instance
    sing : ∀ {A} → ListSyntax A A
    [_] ⦃ sing ⦄ = _∷ []

open Instance public

-- end definition of List syntax

length : {A : Set} → List A → ℕ
length [] = 0
length ( a ∷ as ) = length as + 1

data Bool : Set where
  true : Bool
  false : Bool

infixl 27 _&&_
infixl 26 _||_

_&&_ _||_ : Bool → Bool → Bool

true  && b = b
false && _ = false

true  || _ = true
false || b = b

-- not implementable without some constraints on B
-- ordered : {A B : Set} → (List (A → B)) → A → A → Bool
-- ordered = {!!}

#+end_src agda2
*** Homework:
**** read rest of §1
**** complete the implementation of List and Bool
** Session November 8th
*** discussed data type definitions Bool and List - see above
*** implemented length as an exercise - see above
*** discussed specifications vs. implementations
**** in the case of length the specification can immediately be used as a definition
**** in the case  e.g. of the square root function  with a specification
f : Real⁺ → Real
s.t. ∀ x : Real⁺,  (f x) * (f x) == x

it is more difficult:
+ what exactly is meant by "=="?
+ is the specification complete?
  -> Since for x /= 0 there are two choices for (f x)
     the above does not specify the function f uniquely! 
+ is the specification implementable?
+ if it is, how can f x actually be computed?

**** on with the paper

#+begin_src agda2
data BinTree (A : Set) : Set where
  BLeaf : A → BinTree A
  BNode : BinTree A → BinTree A → BinTree A

foldBinTree : {A B : Set} → (A → B) → (B → B → B) → BinTree A → B
foldBinTree f g (BLeaf x) = f x
foldBinTree f g (BNode t₁ t₂) =
  g (foldBinTree f g t₁) (foldBinTree f g t₂)

data Tree (A : Set) : Set where
  Leaf : A → Tree A
  Node : List (Tree A)  → Tree A

mapL : {A B : Set} → (A → B) → (List A → List B)
mapL f [] = []
mapL f (a ∷ as) = f a ∷ mapL f as

{-# TERMINATING #-}
foldTree : {A B : Set} → (A → B) → (List B → B) → Tree A → B
foldTree f g (Leaf a)        = f a
foldTree f g (Node ts)       = g (mapL (foldTree f g) ts)

mkTree : {A B : Set} → List (A → B) → List A → Tree (List A)
mkTree []       as = Leaf as
mkTree (d ∷ ds) as = Node {!!}  -- t.b.c....


-- trying to dissect the rhs of ptn:  [ filter ((m==).d) xs | m <- rng ]
--  (m==).d  is
--   (m ===_) ∘ d  : A → Bool
{-
     ((m ===_) ∘ d) a
        ={Def. of ∘}
     ((m ===_) (d a))
        ={Notation}
     (m === d a)
-}
--  where _===_ : B → B → Bool

--filter : {A : Set} → (A → Bool) → List A → List A

#+end_src agda2






** Tim: Code that might be useful
#+begin_src agda2

foldList : {A B : Set} → B → (A → B → B) → List A → B
foldList start next [] = start
foldList start next (a ∷ as) = next a (foldList start next as)

mapList : {A B : Set} → (A → B) → List A → List B
mapList f = foldList [] (_∷_ ∘ f)

mapList' : {A B : Set} → (A → B) → List A → List B
mapList' f [] = []
mapList' f (a ∷ as) = f a ∷ mapList' f as

-- exercise: show (on paper !!) that
-- ∀ f, as . mapList f as == mapList' f as 


infix 19 _∈_

data _∈_ {A : Set} : A → List A → Set where
  Here  : {a : A} → (bs : List A) → a ∈ a ∷ bs
  There : {a b : A} → {bs : List A} → a ∈ bs → a ∈ b ∷ bs

∈toℕ : {A : Set} → {a : A} → {as : List A} → a ∈ as → ℕ
∈toℕ (Here _) = 0
∈toℕ (There p) = Succ (∈toℕ p)

foldℕ : {A : Set} → A → (A → A) → ℕ → A
foldℕ start next Zero = start
foldℕ start next (Succ n) = next (foldℕ start next n)

infix 20 [_⋯_]

{-# TERMINATING #-}
[_⋯_] : ℕ → ℕ → List ℕ
[ Zero ⋯ Zero ] = [ 0 ]
[ Zero ⋯ Succ m ] = 0 ∷ ([ Succ Zero ⋯ Succ m ])
[ Succ n ⋯ Zero ] = []
[ Succ n ⋯ Succ m ] = mapList Succ [ n ⋯ m ]

0⋯ : ℕ → List ℕ
0⋯ n = [ 0 ⋯ n ]

-- a possible take on the property of a type
-- being finite and ordered - we could use
-- this as a replacement for  (Bounded b, Enum b, Eq b).
-- To be discussed...

record FinOrd (A : Set) : Set where
  constructor MkFinOrd
  field
    card : ℕ
    allA : List A
    each∈ : ∀ a → a ∈ allA

open FinOrd {{...}} public 

-- e.g., we construct a proof of FinOrd Bool
instance
  finOrdBool : FinOrd Bool
  finOrdBool = MkFinOrd 2 allBool each∈Bool where
    allBool = false ∷ true ∷ []
    each∈Bool : ∀ b → b ∈ allBool
    each∈Bool true  = There (Here [])
    each∈Bool false = Here _

-- types with a FinOrd instance can be mapped to ℕ

toℕ : {A : Set} → {{FA : FinOrd A}} → A → ℕ
toℕ a = ∈toℕ (each∈ a)
-- Exercise: Why can we not write toℕ = ∈toℕ ∘ each∈ ?

-- now, ℕ has a boolean valued (i.e. decidable) equality

infix 30 _===ℕ_

_===ℕ_ : ℕ → ℕ → Bool
Zero   ===ℕ Zero   = true
Zero   ===ℕ Succ m = false
Succ n ===ℕ Zero   = false
Succ n ===ℕ Succ m = n ===ℕ m

-- and a boolean "smaller than" relation:

infix 30 _<ℕ_

_<ℕ_ : ℕ → ℕ → Bool
Zero   <ℕ Zero   = false
Zero   <ℕ Succ m = true
Succ n <ℕ Zero   = false
Succ n <ℕ Succ m = n <ℕ m

-- now, using toℕ, we can define similar relations
-- for any type that has the FinOrd structure

infix 30 _===_ _<_

_===_ _<_ : {A : Set} → {{FA : FinOrd A}} → A → A → Bool
a === b = toℕ a ===ℕ toℕ b
a < b   = toℕ a <ℕ toℕ b

-- now , we can implement a variant of ordered almost exactly
-- like in the paper:

ordered : {A B : Set} → {{ FB : FinOrd B }} → (List (A → B)) → A → A → Bool
ordered []       a b = true
ordered (d ∷ ds) a b = d a < d b || d a === d b  &&  ordered ds a b   

#+end_src agda2

** Session November 15th
*** discussed ptn by an example on the blackboard
*** Nicola had tried to typecheck the code of the paper in Haskell
**** problem : in mkTree, the _==_ operator of the typeClass Eq is used ->
     so, this typeclass constrained has also to be given, like
       (Bounded b , Enum b , Eq b) => ...
*** foldTree
#+begin_src agda2

id : {A : Set} → A → A
id x = x

infixr 25 _++_
_++_ : {A : Set} → List A → List A → List A
[]       ++ bs = bs
(a ∷ as) ++ bs = a ∷ (as ++ bs)

concat : {A : Set} → List (List A) → List A
concat []         = []
concat (as ∷ ass) = as ++ concat ass

flatten : {A : Set} → Tree (List A) → List A
flatten = foldTree id concat

infixl 20 _<:_
_<:_ : {A : Set} → List A → A → List A
[] <: b       = [ b ]
(a ∷ as) <: b = a ∷ (as <: b)

data List' (A : Set) : Set where
  Nil  : List' A
  Cons : A → List' A → List' A
  Snoc : List' A → A → List' A

-- this is a perfectly fine inductive type...
-- but "are" the elements really what one would call lists?

-- Cons a (Snoc Nil b) /= Scon (Cons a Nil) b     !!!  



-- flatten (Node [Leaf [1 , 2], Node [], Node [Leaf [2,3]]])   =  
--      [1,2,2,3]

-- foldTree

#+end_src agda2
** Session November 22nd
*** discussed foldTree and folds in general
*** (code see above) found that foldTree implemented like in the paper
doesn't satisfy the termination checker. In Haskell, this is
not a problem since there is no termination checking.
*** defined BinTree and foldBinTree - no problem with termination there
*** to implement flatten using foldTree, we needed concat, so we 
defined this by pattern matching (i.e. recursively)
*** for concat we needed _++_ . Discussed how to define this by
recursion on the 1st or 2nd argument: it's more convenient to
recurse on the 1st argument: the asymmetry goes back to our using _∷_
as a constructor for lists - if we had used 
  Snoc : List A -> A -> List A
instead, it would be easier to define _++_ by recursion on 2nd argument.
*** Alexandra asked whether we could have both Cons and Snoc as constructors: 
well, technically "we can do what we want" (i.e. have as many constructors
as we like ... see List' above). However, the elements of List' don't
behave like lists, e.g. Cons a []  and  Snoc [] a  are distinct elements,
not merely "different ways to construct a singleton list containing some a : A",
as we might want. In an inductive type, every element is constructed in
a unique way!   
*** Tim: added List syntax (found that online, see above) and used it in  
appropriate places
** Session November 29th
*** read beginning of section 3
*** discussed folds in general and some
special cases: foldList, foldr, foldFalse, foldℕ
*** see [[https://timrichter.github.io/CartesianSeminar/2210/Whiteboard_CS_221129.jpg][Whiteboard]]
