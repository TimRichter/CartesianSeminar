* Code scratchpad for Cartesian seminar October 2022 
We read Gibbons "A pointless derivation of radix sort"
** Session October 18th
*** pointfree (pointless) calculation:
defined in the abstract as calculations on the level of function composition
instead of at the level of function application
*** Nicola: give an example for a "calculation"

#+begin_src agda2
module Gibbons where

data ℕ : Set where
  Zero : ℕ
  Succ : ℕ → ℕ

{-# BUILTIN NATURAL ℕ #-}

idℕ : ℕ → ℕ
idℕ n = n   -- no parentheses around function arguments!

-- the identity function can be defined for any type,
-- i.e. as a parametric function

id : {A : Set} → A → A
id x = x

infixr 10 _+_
infixr 20 _*_

_+_ : ℕ → ℕ → ℕ
Zero + b = b
Succ a + b = Succ (a + b)

_*_ : ℕ → ℕ → ℕ   
Zero * b = Zero
Succ a * b = b + a * b

-- Note! : function application by juxtaposition
-- (the argument isn't put in parentheses) 
double : ℕ → ℕ
double n = 2 * n

quadruple : ℕ → ℕ
quadruple n = 4 * n

quadruple' : ℕ → ℕ
quadruple' n = double (double n)

#+end_src agda2
*** TODO Explain difference between A → (B → C), (A → B) → C, A×B → C !
** Session October 25th
*** complete the example for a pointfree function definition:
#+begin_src agda2

-- goal: define quadruple "pointfree", i.e. without mentioning the argument,
--       this would be
--  quadruple = double ∘ double
--       where the ∘ denotes function composition.
--       So let's define this:

infixl 10 _∘_

_∘_ : {A B C : Set} → (B → C) → (A → B) → (A → C)
(g ∘ f) a = g (f a)

quadruple'' : ℕ → ℕ
quadruple'' = double ∘ double

#+end_src agda2
*** talked about equivalence of types:
two sets X and Y are equivalent if there is a Bijektion f : X → Y
f bijective means: f is injective and f is surjective
*** alternative definition of equivalence: X and Y are equivalent if
∃ f : X → Y ∃ g : Y → X . g ∘ f = id_X  ∧ f ∘ g = id_Y
*** we can do this for the example  A × B → C  is equivalent to A → B → C
#+begin_src agda2

infixr 30 _×_
infixr 30 _,_

record _×_ (A B : Set) : Set where
   constructor _,_
   field
     fst : A
     snd : B

-- "Currying", named after Haskell Curry, a mathematician and
-- philosopher of the 20th century

curry : {A B C : Set} → (A × B → C) → (A → B → C)
curry h a b = h (a , b)

uncurry : {A B C : Set} → (A → B → C) → (A × B → C)
uncurry h (a , b) = h a b

-- infix 25 _==_
infix 9 _==_

data _==_ {A : Set} (a : A) : A → Set where
  refl : a == a

-- equational reasoning notation
{-# BUILTIN EQUALITY _==_ #-}

trans : ∀ {A : Set} {x y z : A} → x == y → y == z → x == z
trans refl refl = refl

symm : ∀ {A : Set} {x y : A} → x == y → y == x
symm refl = refl

infix 11 _QED

_QED : ∀ {A : Set} (x : A) → x == x
x QED = refl

infixr 10 _=⟨_⟩_   -- emacs agda-mode: \langle \rangle
infixr 10 _=⟨⟩_

_=⟨_⟩_ : ∀ {A : Set} (x : A) {y z : A} →
         x == y → y == z → x == z
x =⟨ p ⟩ q = trans p q

_=⟨⟩_ : ∀ {A : Set} (x : A) {y : A} →
        x == y → x == y
x =⟨⟩ q = x =⟨ refl ⟩ q

cong : ∀ {A : Set} {B : Set} {x y : A} →
       (f : A → B) → x == y → f x == f y
cong f refl = refl


-- Now we have the ingredients to prove that
-- curry and uncurry are inverse to each other.
-- We are satisfied with pointwise (extensional)
-- equalities:

id1 : ∀ {A B C : Set} (h : A × B → C) (p : A × B) →
      (uncurry ∘ curry) h p == h p
id1 h p = refl 

-- But we can prove the stronger

id1' : {A B C : Set} → (h : A × B → C) →
      (uncurry ∘ curry) h == h
id1' h = refl

-- and even

id1'' : {A B C : Set} →
        _∘_ {A × B → C} {A → B → C} {A × B → C} uncurry curry == id
id1'' = refl

-- In the other direction, we have

id2 : {A B C : Set} → (h : A → B → C) →
      (a : A) → (b : B) → (curry ∘ uncurry) h a b == h a b
id2 h a b = 
         (curry ∘ uncurry) h a b
           =⟨ refl {- Def. of "∘" -} ⟩
         (curry (uncurry h)) a b
           =⟨ refl {- Def. of "curry" -} ⟩
         (uncurry h) (a , b)
           =⟨ refl {- Def. of "uncurry" -} ⟩
         h a b
           QED

id2' : {A B C : Set} → (h : A → B → C) →
      (curry ∘ uncurry) h == h
id2' h = refl

id2'' : {A B C : Set} →
        _∘_ {A → B → C} {A × B → C} {A → B → C} curry uncurry == id
id2'' = refl

#+end_src agda2
*** DONE (Homework): show uncurry ∘ curry = id  and  curry ∘ uncurry = id 
** Session November 1st
*** did homework of last week, see above
*** read page 1
*** discussed examples of orderings that fit the description
**** words in a dictionary:
the list is the infinite list of functions String → Char
[pick 1st char, pick 2nd char, ...]
**** contacts in a smartphone or phonebook 
the list contains the projection functions to separate fields
(name, surname, phone number, birthday etc.) of a contact
- strictly speaking isn't an instance of the given abstraction,
  because fields are of different types...
*** on with the agda-implementation
#+begin_src agda2

infixr 20 _∷_                   -- input ∷ by typing \::

data List (A : Set) : Set where
     []  : List A
     _∷_ : A → List A → List A

-- List syntax (from https://doisinkidney.com/posts/2019-04-20-ListSyntax.html)
-- allows writing e.g. [ x , y , z ] instead of x ∷ y ∷ z ∷ []

module Instance where
  record ListSyntax (A B : Set) : Set where
    field [_] : B → List A

  open ListSyntax ⦃ ... ⦄ public

  instance
    cons : ∀ {A B : Set} ⦃ _ : ListSyntax A B ⦄
         →  ListSyntax A (A × B)
    [_] ⦃ cons ⦄ (x , xs) = x ∷ [ xs ]

  instance
    sing : ∀ {A} → ListSyntax A A
    [_] ⦃ sing ⦄ = _∷ []

open Instance public

-- end definition of List syntax

-- Length of a list:

length : {A : Set} → List A → ℕ
length [] = 0
length ( a ∷ as ) = 1 + length as

-- Booleans:

data Bool : Set where
  true : Bool
  false : Bool

-- with the basic operations

infixl 27 _&&_  -- "and"
infixl 26 _||_  -- "or"

_&&_ _||_ : Bool → Bool → Bool

true  && b = b
false && _ = false

true  || _ = true
false || b = b

-- not implementable without some constraints on B
-- ordered : {A B : Set} → (List (A → B)) → A → A → Bool
-- ordered = {!!}

#+end_src agda2
*** Homework:
**** read rest of §1
**** complete the implementation of List and Bool
** Session November 8th
*** discussed data type definitions Bool and List - see above
*** implemented length as an exercise - see above
*** discussed specifications vs. implementations
**** in the case of length the specification can immediately be used as a definition
**** in the case  e.g. of the square root function  with a specification
f : Real⁺ → Real
s.t. ∀ x : Real⁺,  (f x) * (f x) == x

it is more difficult:
+ what exactly is meant by "=="?
+ is the specification complete?
  -> Since for x /= 0 there are two choices for (f x)
     the above does not specify the function f uniquely! 
+ is the specification implementable?
+ if it is, how can f x actually be computed?

**** on with the paper

#+begin_src agda2
data BinTree (A : Set) : Set where
  BLeaf : A → BinTree A
  BNode : BinTree A → BinTree A → BinTree A

foldBinTree : {A B : Set} → (A → B) → (B → B → B) → BinTree A → B
foldBinTree f g (BLeaf x) = f x
foldBinTree f g (BNode t₁ t₂) =
  g (foldBinTree f g t₁) (foldBinTree f g t₂)

data Tree (A : Set) : Set where
  Leaf : A → Tree A
  Node : List (Tree A)  → Tree A

-- Here is the standard "map" for List:

mapL : {A B : Set} → (A → B) → (List A → List B)
mapL f [] = []
mapL f (a ∷ as) = f a ∷ mapL f as

-- Remark:
-- A type constructor |F : Set → Set| is called a "functor"
-- if a (higher order, parametric in A B...) function
-- map : {A B : Set} → (A → B) → (F A → F B)
-- can be implemented (satisfying some laws...).
-- With mapL, List becomes a functor.

-- The termination checker doesn't see that foldTree
-- terminates since the recursive call is under a mapL...
-- We ask it to trust us that it will terminate:

--{-# TERMINATING #-}
mutual
  foldTree : {A B : Set} → (A → B) → (List B → B) → Tree A → B
  foldTree f g (Leaf a)        = f a
  foldTree f g (Node ts)       = g (foldTreeMap f g ts)
  -- Formerly we had
  -- foldTree f g (Node ts)       = g (mapL (foldTree f g) ts)
  -- (and no "mutual") and needed to cheat using {-# TERMINATING #-}
  -- This (unsurprisingly in hindsight) became a problem when we tried
  -- to prove the universal property of foldTree.

  foldTreeMap : {A B : Set} → (A → B) → (List B → B) → List (Tree A) → List B
  foldTreeMap f g [] = []
  foldTreeMap f g (t ∷ ts) = foldTree f g t ∷ foldTreeMap f g ts 

-- We can now prove that foldTreeMap deserves its name:
-- foldTreeMap f g is (extensionlly equal to ... see below) mapL (foldTree f g)

foldTreeMap←foldTree : {A B : Set} → (f : A → B) → (g : List B → B) → (ts : List (Tree A)) →
                       foldTreeMap f g ts == mapL (foldTree f g) ts
foldTreeMap←foldTree f g []       = refl
foldTreeMap←foldTree f g (t ∷ ts) = cong (foldTree f g t ∷_) (foldTreeMap←foldTree f g ts)

{-  we'll take this up later...

mkTree : {A B : Set} → List (A → B) → List A → Tree (List A)
mkTree []       as = Leaf as
mkTree (d ∷ ds) as = Node {!!}  -- t.b.c....


-- trying to dissect the rhs of ptn:  [ filter ((m==).d) xs | m <- rng ]
--  (m==).d  is
--   (m ===_) ∘ d  : A → Bool

--     ((m ===_) ∘ d) a
--        ={Def. of ∘}
--     ((m ===_) (d a))
--        ={Notation}
--     (m === d a)

--  where _===_ : B → B → Bool

filter : {A : Set} → (A → Bool) → List A → List A

-}

#+end_src agda2

** Tim (Nov 13th): Code that might be useful
#+begin_src agda2

foldList : {A B : Set} → B → (A → B → B) → List A → B
foldList start next [] = start
foldList start next (a ∷ as) = next a (foldList start next as)

mapList : {A B : Set} → (A → B) → List A → List B
mapList f = foldList [] (_∷_ ∘ f)

-- exercise: show (on paper !!) that
-- ∀ f ∀ as.  mapList f as == mapL f as
-- See definition of mapL above.

-- We define a type family to express, for any
-- type A, any a : A and and as : List A, the
-- proposition that a is an element of as:

infix 19 _∈_

data _∈_ {A : Set} : A → List A → Set where
  Here  : {a : A}   → (bs : List A)          → a ∈ a ∷ bs
  There : {a b : A} → {bs : List A} → a ∈ bs → a ∈ b ∷ bs

-- An element (i.e. proof) of a ∈ as gives a position
-- in as where a occurs (we start positions at 0 !!):
∈toℕ : {A : Set} → {a : A} → {as : List A} → a ∈ as → ℕ
∈toℕ (Here _)  = 0
∈toℕ (There p) = Succ (∈toℕ p)

-- We prove a property we need later (Appendix B)
∈MapL : {A B : Set} → (f : A → B) → {a : A} → {as : List A} →
        a ∈ as → f a ∈ mapL f as
∈MapL f (Here bs) = Here (mapL f bs)
∈MapL f (There a∈bs) = There (∈MapL f a∈bs)

-- Here is the fold of the type ℕ:
foldℕ : {A : Set} → A → (A → A) → ℕ → A
foldℕ start next Zero = start
foldℕ start next (Succ n) = next (foldℕ start next n)

-- We introduce notation for a list of
-- consecutive natural numbers
infix 20 [_⋯_]

{-# TERMINATING #-}
[_⋯_] : ℕ → ℕ → List ℕ
[ Zero ⋯ m ] = 0 ∷ [ (Succ Zero) ⋯ m ]
[ Succ n ⋯ Zero ] = []
[ Succ n ⋯ Succ m ] = mapL Succ [ n ⋯ m ]

-- and for the list of numbers from 0 to n
0⋯ : ℕ → List ℕ
0⋯ n = [ 0 ⋯ n ]

-- A possible take on the property of a type
-- being finite and ordered - we could use
-- this as a replacement for  (Bounded b, Enum b, Eq b).
-- To be discussed...
-- The uniqueness component ensures that allA has no
-- duplicates...

record FinOrd (A : Set) : Set where
  constructor MkFinOrd
  field
    card : ℕ
    allA : List A
    each∈ : ∀ a → a ∈ allA
    -- uniqueness : mapL (λ a → ∈toℕ (each∈ a)) allA == [ 1 ⋯ card ]
    uniqueness : length allA == card -- this is enough, thanks Nuria!

open FinOrd {{...}} public 

-- as an example, we construct a proof of FinOrd Bool
instance
  finOrdBool : FinOrd Bool
  finOrdBool = MkFinOrd 2 allBool each∈Bool uniqueBool where
    allBool = false ∷ true ∷ []
    each∈Bool : ∀ b → b ∈ allBool
    each∈Bool true  = There (Here [])
    each∈Bool false = Here _
    uniqueBool = refl

-- Exercise: Can you define another element of FinOrd Bool ?

-- An instance of FinOrd A defines a map from A to ℕ

toℕ : {A : Set} → {{FA : FinOrd A}} → A → ℕ
toℕ a = ∈toℕ (each∈ a)

-- Exercise: Why can we not write toℕ = ∈toℕ ∘ each∈ ?
-- Answer: because each∈ is a dependent function and
--   we defined _∘_ only for nondependent functions. 
--
-- Note that with this definition, we can now write the
-- type of the "uniqueness" component of FinOrd as
-- mapL toℕ allA = [ 1 ⋯ card ].

-- We want to show that an element of FinOrd A  defines
-- a (boolean valued, thus decidable) equality and a
-- boolean valued "smaller than" relation on A.
-- First, ℕ has a boolean valued equality

infix 30 _===ℕ_

_===ℕ_ : ℕ → ℕ → Bool
Zero   ===ℕ Zero   = true
Zero   ===ℕ Succ m = false
Succ n ===ℕ Zero   = false
Succ n ===ℕ Succ m = n ===ℕ m

-- and a boolean valued "smaller than" relation:

infix 30 _<ℕ_

_<ℕ_ : ℕ → ℕ → Bool
Zero   <ℕ Zero   = false
Zero   <ℕ Succ m = true
Succ n <ℕ Zero   = false
Succ n <ℕ Succ m = n <ℕ m

-- Using toℕ, we can define similar relations
-- for any type with a given FinOrd structure

infix 30 _===_ _<_

_===_ _<_ : {A : Set} → {{FA : FinOrd A}} → A → A → Bool
a === b = toℕ a ===ℕ toℕ b
a < b   = toℕ a <ℕ toℕ b

-- And with this, we can implement a variant of ordered
-- almost exactly like in the paper:

ordered : {A B : Set} → {{ FB : FinOrd B }} → (List (A → B)) → A → A → Bool
ordered []       a b = true
ordered (d ∷ ds) a b = d a < d b || d a === d b  &&  ordered ds a b   

-- In the paper, there is the "range" for any bounded, enumerated type:
-- rng :: (Bounded a, Enum a) => [a]
-- rng = [minBound..maxBound]
--
-- In our setting, allA plays this role. So we define  
-- (making the type parameter explicit is a matter of taste...):

rng : (A : Set) → {{FinOrd A}} → List A
rng A = allA

-- Exercise: for finOrdBool : FinOrd Bool  given above
-- and the other element of FinOrd Bool you (hopefully)
-- found in the exercise there, compare the resulting
-- relations _===_ and _<_ !

#+end_src agda2

** Session November 15th
*** discussed ptn by an example on the blackboard
*** Nicola had tried to typecheck the code of the paper in Haskell
**** problem : in mkTree, the _==_ operator of the typeClass Eq is used ->
     so, this typeclass constrained has also to be given, like
       (Bounded b , Enum b , Eq b) => ...
*** foldTree
#+begin_src agda2

infixr 25 _++_
_++_ : {A : Set} → List A → List A → List A
[]       ++ bs = bs
(a ∷ as) ++ bs = a ∷ (as ++ bs)

concat : {A : Set} → List (List A) → List A
concat []         = []
concat (as ∷ ass) = as ++ concat ass

flatten : {A : Set} → Tree (List A) → List A
flatten = foldTree id concat

infixl 20 _<:_
_<:_ : {A : Set} → List A → A → List A
[] <: b       = [ b ]
(a ∷ as) <: b = a ∷ (as <: b)

data List' (A : Set) : Set where
  Nil  : List' A
  Cons : A → List' A → List' A
  Snoc : List' A → A → List' A

-- this is a perfectly fine inductive type...
-- but "are" the elements really what one would call lists?

-- Cons a (Snoc Nil b) /= Scon (Cons a Nil) b     !!!  


#+end_src agda2
** Session November 22nd
*** discussed foldTree and folds in general
*** (code see above) found that foldTree implemented like in the paper
doesn't satisfy the termination checker. In Haskell, this is
not a problem since there is no termination checking.
*** defined BinTree and foldBinTree - no problem with termination there
*** to implement flatten using foldTree, we needed concat, so we 
defined this by pattern matching (i.e. recursively)
*** for concat we needed _++_ . Discussed how to define this by
recursion on the 1st or 2nd argument: it's more convenient to
recurse on the 1st argument: the asymmetry goes back to our using _∷_
as a constructor for lists - if we had used 
  Snoc : List A -> A -> List A
instead, it would be easier to define _++_ by recursion on 2nd argument.
*** Alexandra asked whether we could have both Cons and Snoc as constructors: 
well, technically "we can do what we want" (i.e. have as many constructors
as we like ... see List' above). However, the elements of List' don't
behave like lists, e.g. Cons a []  and  Snoc [] a  are distinct elements,
not merely "different ways to construct a singleton list containing some a : A",
as we might want. In an inductive type, every element is constructed in
a unique way!   
*** Tim: added List syntax (found that online, see above) and used it in  
appropriate places
** Session November 29th
*** read beginning of section 3
*** discussed folds in general and some
special cases: foldList, foldr, foldFalse, foldℕ
*** see [[https://timrichter.github.io/CartesianSeminar/2210/Whiteboard_CS_221129.jpg][Whiteboard]]
*** Tim (Dec 26th): some code
#+begin_src agda2

-- for foldList and foldℕ see above.

-- We define the type False

data False : Set where

-- and the corresponding fold (ex falso quodlibet)

foldFalse : {A : Set} → False → A
foldFalse ()    -- this is an "absurd" pattern matching

-- foldr  ... a (better?) fold for lists

foldr : {A B : Set} → (A → B → B) → B → List A → B
foldr f e []       = e
foldr f e (a ∷ as) = f a (foldr f e as)

-- the fold for Bool:

foldBool : {A : Set} → A → A → Bool → A
foldBool casetrue casefalse true  = casetrue
foldBool casetrue casefalse false = casefalse

-- is more commonly written like this:

if_then_else_ : {A : Set} → Bool → A → A → A
if b then t else f = foldBool t f b

-- Exercise: compare foldr with foldList !

#+end_src agda2
** Session December 6th
*** discussed universal property of foldr
*** checked for example sum
*** fusion law for foldr
*** made an example for neg ∘ sum
*** see [[https://timrichter.github.io/CartesianSeminar/2210/Whiteboard_CS_20221206_1050.jpg]Whiteboard_CS_20221206_1050.jpg]], [[https://timrichter.github.io/CartesianSeminar/2210/Whiteboard_CS_20221206_1120.jpg][Whiteboard_CS_20221206_1120.jpg]], [[https://timrichter.github.io/CartesianSeminar/2210/Whiteboard_CS_20221206_1146.jpg][Whiteboard_CS_20221206_1146.jpg]]
*** Tim (Dec 26th): some code
#+begin_src agda2

-- in the paper we read: ...the universal property for the standard foldr 
-- on lists states, for strict h , that h = foldr f e precisely if
-- h [] = e
-- h (a:as) = f a (h as)
--
-- We have to be a little more exact about the equalities here. h = foldr f e
-- is meant to be an extensional equality of functions. Let's define notation
-- for this:

infix 9 _=∙=_  -- type \.1  to get ∙  

_=∙=_ : {A B : Set} → (A → B) → (A → B) → Set
_=∙=_ {A} f g = (a : A) → f a == g a  

-- The equation h [] = e is a simple equation (we have to write it with _==_).
-- The 2nd equation is meant to hold for any a : A and any as : List A.
-- So, mathematically, the universal prop. of foldr says:
-- h =∙= foldr f e   ⇔   1) h [] == e
--                       2) ∀ a : A . ∀ as : List A . h (a ∷ as) == f a (h as)

-- Let's define types, depending on h, f an e, that express
-- the two equations: The first one is a simple equality (depending
-- only on h and e):

FoldrUPCond1 : {A B : Set} → (List A → B) → B → Set
FoldrUPCond1 h e =   h [] == e 

-- the second depends only on h and f and is a quantified equality:

FoldrUPCond2 : {A B : Set} → (List A → B) → (A → B → B) → Set
FoldrUPCond2 {A} h f = (a : A) → (as : List A) →
                       h (a ∷ as) == f a (h as)

-- That h, f and e satisfy the two conditions can now be expressed
-- by the cartesian product of FoldrUPCond1 h f e and FoldrUPCond2 h f e, and
-- the universal property says that this type is "logically equivalent"
-- to the type h =∙= foldr f e. "Logical equivalence" between two types
-- means just that we have functions in both directions -- we do not
-- need these functions to be inverses of each other (compare notes
-- on "equivalence" of October 25th above).
-- Let's define a type for logical equivalence:

infix 8 _⇔_  -- \iff

record _⇔_ (A B : Set) : Set where
  constructor Mk⇔
  field
    to   : A → B
    from : B → A

-- We can now state the universal property of foldr as

FoldrUP : {A B : Set} → (h : List A → B) → (f : A → B → B) → (e : B) →
          h =∙= foldr f e ⇔ (FoldrUPCond1 h e × FoldrUPCond2 h f)
          
-- and prove it using the definition of foldr:

FoldrUP h f e = Mk⇔ to from where
  -- we define a helper function for the
  -- second component of "to".
  -- Note that we don't need induction on as!
  to2 : h =∙= foldr f e → FoldrUPCond2 h f
  to2 hEfo a as = 
    h (a ∷ as)
      =⟨ hEfo (a ∷ as) ⟩
    foldr f e (a ∷ as)
      =⟨ refl {- Def. of foldr -}  ⟩
    f a (foldr f e as)
      =⟨ cong (f a) (symm (hEfo as)) ⟩
    f a (h as)
      QED
      
  to : h =∙= foldr f e → FoldrUPCond1 h e × FoldrUPCond2 h f
  to hEfo = (hEfo [] , to2 hEfo)

  -- for from, we do need induction!
  from : FoldrUPCond1 h e × FoldrUPCond2 h f  → (h =∙= foldr f e)
  from (c1 , c2) [] = c1
  from (c1 , c2) (a ∷ as) = 
    h (a ∷ as)
      =⟨ c2 a as ⟩
    f a (h as)
      =⟨ cong (f a) (from (c1 , c2) as) ⟩
    f a (foldr f e as)
      QED

-- Let's formulate and prove the fusion law for foldr similarly:

FoldrFusionCond1 : {B B' : Set} → (B → B') → B → B' → Set
FoldrFusionCond1 g e e' =   g e == e'

FoldrFusionCond2 : {A B B' : Set} → (B → B') → (A → B → B) → B → (A → B' → B') → Set
FoldrFusionCond2 {A} g f e f' =   (a : A) → g ∘ f a ∘ foldr f e =∙= f' a ∘ g ∘ foldr f e

-- the fusion conditions are logically equivalent to the FoldrUP conditions
-- for the function h = g ∘ foldr f e:

FoldrFusion⇔UP1 : {A B B' : Set} → (g : B → B') → (f : A → B → B) → (e : B) → (e' : B') →
                  FoldrFusionCond1 g e e' ⇔ FoldrUPCond1 (g ∘ foldr f e) e'
FoldrFusion⇔UP1 g f e e' = Mk⇔ to from where
  to : FoldrFusionCond1 g e e' → FoldrUPCond1 (g ∘ foldr f e) e'
  to fc1 = 
    (g ∘ foldr f e) []
      =⟨ refl {- Def. _∘_ -} ⟩
    g (foldr f e [])
      =⟨ refl {- Def. foldr -} ⟩
    g e
      =⟨ fc1 ⟩
    e'
      QED
  from : FoldrUPCond1 (g ∘ foldr f e) e' → FoldrFusionCond1 g e e'
  from c1 = 
    g e
      =⟨ refl {- Def. foldr -} ⟩
    g (foldr f e [])
      =⟨ c1 ⟩
    e'
      QED

-- Note that, although both of the types represent quantified (equality) statements,
-- we again do not need induction!

FoldrFusion⇔UP2 : {A B B' : Set} → (g : B → B') → (f : A → B → B) → (e : B) → (f' : A → B' → B') →
                  FoldrFusionCond2 g f e f' ⇔ FoldrUPCond2 (g ∘ foldr f e) f'
FoldrFusion⇔UP2 g f e f' = Mk⇔ to from where
  to : FoldrFusionCond2 g f e f' → FoldrUPCond2 (g ∘ foldr f e) f'
  to fc2 a as = 
    g (foldr f e (a ∷ as))
      =⟨ refl {- Def. foldr -} ⟩
    g (f a (foldr f e as))
      =⟨ fc2 a as ⟩
    f' a (g (foldr f e as))
      QED 
  from : FoldrUPCond2 (g ∘ foldr f e) f' → FoldrFusionCond2 g f e f'
  from c1 a as = 
    g (f a (foldr f e as))
      =⟨ refl {- Def. foldr -}  ⟩
    g ( foldr f e (a ∷ as))
      =⟨ c1 a as ⟩
    f' a (g (foldr f e as))
      QED

-- We prove that logical equivalence is an equivalence relation

⇔Refl : {A : Set} → A ⇔ A
⇔Refl = Mk⇔ id id

⇔Symm : {A B : Set} → A ⇔ B → B ⇔ A
⇔Symm A⇔B = Mk⇔ (A⇔B .from) (A⇔B .to) where
  open _⇔_

⇔Trans : {A B C : Set} → A ⇔ B → B ⇔ C → A ⇔ C
⇔Trans A⇔B B⇔C = Mk⇔ ((B⇔C .to) ∘ (A⇔B .to)) ((A⇔B .from) ∘ (B⇔C .from)) where
  open _⇔_

-- , introduce syntax for "⇔-Reasoning" (similar to the by now
-- familiar equational reasoning):

infix 9 _QED⇔

_QED⇔ : (A : Set) → A ⇔ A
A QED⇔ = ⇔Refl

infixr 8 _⇔⟨_⟩_

_⇔⟨_⟩_ : (A : Set) → {B C : Set} → A ⇔ B → B ⇔ C → A ⇔ C
A ⇔⟨ A⇔B ⟩ B⇔C = ⇔Trans A⇔B B⇔C

-- and, using 

→× : {A A' B B' : Set} → (A → A') × (B → B') → A × B → A' × B'
→× (f , g) (a , b) = (f a , g b)

-- (i.e. "a pair of functions defines a function of pairs"), we
-- prove that a pair of logical equivalence implies a logical equivalence
-- of pairs:

⇔× : {A A' B B' : Set} → (A ⇔ A') × (B ⇔ B') → A × B  ⇔  A' × B'
⇔× (A⇔A' , B⇔B') = Mk⇔ (→× (A⇔A' .to , B⇔B' .to)) (→× ((A⇔A' .from) , (B⇔B' .from))) where
  open _⇔_

-- Now we can prove the fusion law for foldr:

FoldrFusion : {A B B' : Set} → (g : B → B') → (f : A → B → B) → (e : B) →
              (f' : A → B' → B') → (e' : B') →
              g ∘ foldr f e =∙= foldr f' e'  ⇔ FoldrFusionCond1 g e e' × FoldrFusionCond2 g f e f'
FoldrFusion {A} g f e f' e' =
  let
    h = g ∘ foldr f e
  in
    h =∙= foldr f' e'
      ⇔⟨ FoldrUP h f' e' ⟩
    FoldrUPCond1 h e' × FoldrUPCond2 h f'
      ⇔⟨ ⇔× (⇔Symm (FoldrFusion⇔UP1 g f e e') , ⇔Symm (FoldrFusion⇔UP2 g f e f')) ⟩
    FoldrFusionCond1 g e e' × FoldrFusionCond2 g f e f'
      QED⇔

-- The stronger condition

FoldrFusionCond2' : {A B B' : Set} → (B → B') → (A → B → B) → (A → B' → B') → Set
FoldrFusionCond2' {A} g f f' = (a : A) → g ∘ f a =∙= f' a ∘ g

-- of course implies FoldrFusionCond2:

FoldrFusionCond2'→Cond2 :  {A B B' : Set} → (g : B → B') → (f : A → B → B) →
                           (e : B) → (f' : A → B' → B') →
                           FoldrFusionCond2' g f f' → FoldrFusionCond2 g f e f'
FoldrFusionCond2'→Cond2 g f e f' c2' a as = c2' a (foldr f e as) 

-- Thus we can prove:

FoldrFusion' : {A B B' : Set} → (g : B → B') → (f : A → B → B) → (e : B) →
               (f' : A → B' → B') → (e' : B') →
               FoldrFusionCond1 g e e' × FoldrFusionCond2' g f f' →
               g ∘ foldr f e =∙= foldr f' e'
FoldrFusion' g f e f' e' (fc1 , fc2') =
  _⇔_.from (FoldrFusion g f e f' e') (fc1 , FoldrFusionCond2'→Cond2 g f e f' fc2')

-- Note that this is not a logical equivalence, but just an implication!


#+end_src agda2
** Session December 13th
*** Josefine presented the homework to prove the fusion law from the universal property of foldr
*** Discussed conditions on g such that the fusion law allows us to define
f' and e' from arbitrary f and e such that  g ∘ foldr f e = foldr f' e'. 
This is possible e.g. if g is an is an isomorphism or if g is constant.
*** Read the rest of chpt. 3: fusion law for foldt
*** Read first § of chpt.4: Gibbons wants to write mkTree as a foldr. We wrote down
the types of mkTree and the parameters for foldr.
*** see [[https://timrichter.github.io/CartesianSeminar/2210/Whiteboard_CS_221213_1.jpg][Whiteboard_CS_221213_1.jpg]] , [[https://timrichter.github.io/CartesianSeminar/2210/Whiteboard_CS_221213_2.jpg][Whiteboard_CS_221213_2.jpg]] , [[https://timrichter.github.io/CartesianSeminar/2210/Whiteboard_CS_221213_3.jpg][Whiteboard_CS_221213_3.jpg]]
*** Tim (Jan 2nd): some more code
#+begin_src agda2

-- I'd like to complete the definition of mkTree using, as in the
-- code section of Nov 13th above, the class FinOrd instead of the
-- paper's type class constraints (Enum, Bounded, Eq ...) 

-- First a standard function: Lists can be filtered w.r.t. a boolean predicate:

filter : {A : Set} → (A → Bool) → List A → List A
filter p [] = []
filter p (a ∷ as) = if (p a) then a ∷ filter p as else filter p as

-- Note the foldBool in if_then_else_ disguise!

-- Using filter, we can define ptn as:

ptn : {A B : Set} → {{ FinOrd B }} → (A → B) → List A → List (List A)
ptn {A} {B} d as = mapL (λ m → filter ((m ===_) ∘ d) as) (rng B)

-- (The "list comprehension" notation used in the paper is just syntactic sugar for this.)
-- Now we can complete the definition of mkTree

mkTree : {A B : Set} → {{ FinOrd B }} → List (A → B) → List A → Tree (List A)
mkTree []       as = Leaf as
mkTree (d ∷ ds) as = Node (mapL (mkTree ds) (ptn d as))

-- and give the definition of treesort:

treesort : {A B : Set} → {{ FinOrd B }} → List (A → B) → List A → List A
treesort ds as = flatten (mkTree ds as)


#+end_src agda2
** Session January 3rd
*** discussed the Agda implementation of FoldUP
*** in particular we discussed the many different "equalities"
in the paper, in Haskell, and in our Agda implementation:
**** _=_  used in the paper (and in mathematics):
***** heavily overloaded !!
***** in Zermelo-Fraenkel set theory (where everything is a set !)
it has a precise meaning: two sets are equal iff they have the
same elements!
***** the symbol is used in programming languages (including Haskell and Agda)
as an assignment operator (not as a relation at all!)
**** _==_
***** in Haskell has type
_==_ :: (Eq b) => b -> b -> bool
where Eq is a Haskell type class
***** in our Agda implementation it has type
_==_ : {A : Set} → A → A → Set
and is called "propositional equality" or "identity type"
(compare script and literature given there).
**** _===ℕ_ : ℕ → ℕ → Bool
as used above is (as any Agda function) total and thus
gives a decidable equality relation on ℕ.
-- Exercise: prove that ∀ n m : ℕ.  n == m  ⇔  (n ===ℕ m) == true   !
**** _===_ : {A : Set} → {{FinOrd A}} → A → A → Bool 
as defined above defines a boolean valued equality for any
FinOrd-instance of type A
-- Exercise (might be tricky...): prove
   {A : Set} → {{FinOrd A}} → (a b : A) → a == b  ⇔  (a === b) == true
**** _=∙=_  Notation we use above for extensional (i.e. pointwise) equality
of functions.
-- Exercises: 
   - prove   {A B : Set} → (f g : A → B) → f == g → f =∙= g   !
   - what about 
             {A B : Set} → (f g : A → B) → f =∙= g → f == g   ?
*** see [[https://timrichter.github.io/CartesianSeminar/2210/Whiteboard_CS_230103.jpg]Whiteboard_CS_230103.jpg]] 
** Tim (Jan 8th)  
#+begin_src agda2

-- Fusion law for foldTree
--
-- Similar to what was done above for foldr, we want to formulate
-- and prove the universal property and the fusion law for
-- foldTree

-- After running into some difficulties with a definition that
-- needed the {-# TERMINATION #-}-pragma to be accepted, we 
-- defined foldTree mutually with foldTreeMap:
-- mutual
--   foldTree : {A B : Set} → (A → B) → (List B → B) → Tree A → B
--   foldTree f g (Leaf a)        = f a
--   foldTree f g (Node ts)       = g (foldTreeMap f g ts)
-- 
--   foldTreeMap : {A B : Set} → (A → B) → (List B → B) → List (Tree A) → List B
--   foldTreeMap f g [] = []
--   foldTreeMap f g (t ∷ ts) = foldTree f g t ∷ foldTreeMap f g ts 

-- The paper (p. 3f) states the UP as
--   h = foldt f g    <->   h . Leaf = f   and   h . Node = g . map h
--
-- These equalities are all to be interpreted as extensional equalities
-- of functions (of types Tree A → B , A → B, and List (Tree A) → B , respectively).
-- So, to prove the universal property, for any h, f, g of appropriate
-- types we have to provide an element of the type
--    h =∙= foldTree f g  ⇔  (h ∘ Leaf =∙= f)  ×  (h ∘ Node =∙= g ∘ mapL h)
--
-- In the case of foldr above, we introduced type families for the components on
-- the right. We could do this here as well (something like FoldTreeUPCond1 h f ... a.s.o.).
-- But it would make the code longer and less readable, so we won't do it.

-- However, we need some preliminaries:
-- 1) mapL preserves _=∙=_ !

mapLPres=∙= : {A B : Set} → (f g : A → B) → f =∙= g → mapL f =∙= mapL g
mapLPres=∙= f g fEEg [] = refl
mapLPres=∙= f g fEEg (a ∷ as) =
  mapL f (a ∷ as)
    =⟨ refl ⟩
  f a ∷ mapL f as
    =⟨ cong (_∷ mapL f as) (fEEg a) ⟩
  g a ∷ mapL f as
    =⟨ cong (g a ∷_) (mapLPres=∙= f g fEEg as) ⟩
  g a ∷ mapL g as
    =⟨ refl ⟩
  mapL g (a ∷ as)
    QED

-- 2) =∙= is an equivalence relation

==→=∙= : ∀ {A B : Set} {f g : A → B} → f == g → f =∙= g
==→=∙= refl a = refl

refl∙ : ∀ {A B : Set} {f : A → B} → f =∙= f
refl∙ = ==→=∙= refl

=∙=Trans : ∀ {A B : Set} {f g h : A → B} → f =∙= g → g =∙= h → f =∙= h
=∙=Trans fEg gEh a = trans (fEg a) (gEh a)

=∙=Symm : ∀ {A B : Set} {f g : A → B} → f =∙= g → g =∙= f
=∙=Symm fEg a = symm (fEg a)  

-- As the whole paper is about the "pointfree" style (discarding idle variables),
-- it is surely appropriate to define equational reasoning for =∙=

infix 9 _QED=∙=

_QED=∙= : {A B : Set} → (f : A → B) → f =∙= f
f QED=∙= = refl∙

infixr 8 _=∙=⟨_⟩_

_=∙=⟨_⟩_ : {A B : Set} → (f : A → B) → {g h : A → B} → f =∙= g → g =∙= h → f =∙= h
f =∙=⟨ fEEg ⟩ gEEh = =∙=Trans fEEg gEEh

-- 3) for any function g, precomposition with
--    g as well as postcomposition with g preserve =∙= :

pre∘Pres=∙= : {A B C : Set} → (g : A → B) → {f h : B → C} →
               f =∙= h → f ∘ g =∙= h ∘ g
pre∘Pres=∙= g {f} {h} fEh a = fEh (g a)

post∘Pres=∙= : {A B C : Set} → (g : B → C) → {f h : A → B} →
               f =∙= h → g ∘ f =∙= g ∘ h
post∘Pres=∙= g {f} {h} fEh a = cong g (fEh a)


-- 4) Our final preliminary is the following lemma, which follows easily
--    from mapPres=∙= and that foldTreeMap f g =∙= mapL (foldTree f g), a
--    fact we proved above.

foldTreeUPLemma : {A B : Set} → (h : Tree A → B) → (f : A → B) → (g : List B → B) →
                  h =∙= foldTree f g   →  mapL h =∙= foldTreeMap f g
foldTreeUPLemma h f g hEfTfg = 
    mapL h
      =∙=⟨ mapLPres=∙= _ _ hEfTfg ⟩
    mapL (foldTree f g)
      =∙=⟨ =∙=Symm (foldTreeMap←foldTree f g) ⟩
    foldTreeMap f g
      QED=∙=

-- Now we can formulate and prove the universal property of foldTree

foldTreeUP : {A B : Set} → (h : Tree A → B) → (f : A → B) → (g : List B → B) →
             h =∙= foldTree f g  ⇔
             (h ∘ Leaf =∙= f)  ×  (h ∘ Node =∙= g ∘ mapL h)
foldTreeUP h f g = Mk⇔ to from where
  to2 : h =∙= foldTree f g → h ∘ Node =∙= g ∘ mapL h
  to2 hEfTfg =
    h ∘ Node
      =∙=⟨ pre∘Pres=∙= Node hEfTfg ⟩
    (foldTree f g) ∘ Node
      =∙=⟨  ==→=∙= refl ⟩
    g ∘ (foldTreeMap f g)
      =∙=⟨ post∘Pres=∙= g (=∙=Symm (foldTreeUPLemma h f g hEfTfg)) ⟩
    g ∘ mapL h
      QED=∙=
  to : h =∙= foldTree f g →
       (h ∘ Leaf =∙= f)  ×  (h ∘ Node =∙= g ∘ mapL h)
  to hEfTfg = ((λ a → hEfTfg (Leaf a)) , to2 hEfTfg)

  -- as we defined foldTree mutually with foldTreeMap, we are bound to also
  -- define from (which proves a property of foldTree) mutually with fromMap:
  mutual
    from : (h ∘ Leaf =∙= f)  ×  (h ∘ Node =∙= g ∘ mapL h) →
           h =∙= foldTree f g
    from (c1 , c2) (Leaf a)   = c1 a
    from (c1 , c2) (Node tas) =
      h (Node tas)
        =⟨ c2 tas ⟩
      g (mapL h tas)
        =⟨ cong g (fromMap (c1 , c2) tas) ⟩
      g (foldTreeMap f g tas)
        QED
        
    fromMap : (h ∘ Leaf =∙= f)  ×  (h ∘ Node =∙= g ∘ mapL h) →
              mapL h =∙= foldTreeMap f g
    fromMap (c1 , c2) [] = refl
    fromMap (c1 , c2) (t ∷ ts) = 
       h t ∷ mapL h ts
         =⟨ cong (_∷ mapL h ts) (from (c1 , c2) t) ⟩
       foldTree f g t ∷ mapL h ts
         =⟨ cong (foldTree f g t ∷_) (fromMap (c1 , c2) ts) ⟩
       foldTree f g t ∷ foldTreeMap f g ts
         QED

-- Fusion law for foldTree
-- Gibbons doesn't formulate this as an equivalence but only states
-- that (for h f g f' g' of appropriate types) we have
--
--     (h ∘ f =∙= f') × (h ∘ g =∙= g' ∘ mapL h) →
--     h ∘ foldTree f g =∙= foldTree f' g'
--

-- Again, we need preliminaries:

{- do not really need this as its proof is trivial ... but why?
-- Associativity of ∘

∘Assoc : {A B C D : Set} → (f : C → D) → (g : B → C) → (h : A → B) →
         f ∘ g ∘ h =∙= f ∘ (g ∘ h)
∘Assoc f g h = refl∙  -- why does this work?
-}

-- mapL preserves function composition

mapPres∘ : {A B C : Set} → (f : B → C) → (g : A → B) →
            mapL f ∘ mapL g =∙= mapL (f ∘ g)
mapPres∘ f g [] = refl
mapPres∘ f g (a ∷ as) = 
  (mapL f ∘ mapL g) (a ∷ as)
    =⟨ refl {- Def. _∘_ -} ⟩
  mapL f (mapL g (a ∷ as))
    =⟨ refl {- Def. mapL -} ⟩
  mapL f (g a ∷ mapL g as)
    =⟨ refl {- Def. mapL again and Def _∘_ -}⟩
  (f ∘ g) a ∷ (mapL f ∘ mapL g) as
    =⟨ cong ((f ∘ g) a ∷_) (mapPres∘ f g as) ⟩
  (f ∘ g) a ∷ mapL (f ∘ g) as
    QED


foldTreeFusion : {A B B' : Set} → (h : B → B') →
                 (f  : A → B ) → (g  : List B  → B ) →
                 (f' : A → B') → (g' : List B' → B') →
                 (h ∘ f =∙= f') × (h ∘ g =∙= g' ∘ mapL h) →
                  h ∘ foldTree f g =∙= foldTree f' g'
foldTreeFusion h f g f' g' (hfEf' , hgEg'mh) =
  -- idea is simple: we use (the from direction) of foldTreeUP in a special case
  _⇔_.from (foldTreeUP (h ∘ foldTree f g) f' g') (c1 , c2) where
    c1 : h ∘ foldTree f g ∘ Leaf =∙= f'
    c1 = 
      h ∘ foldTree f g ∘ Leaf
        =∙=⟨ post∘Pres=∙= h refl∙ ⟩
      h ∘ f
        =∙=⟨ hfEf' ⟩
      f'
        QED=∙=
    c2 : h ∘ foldTree f g ∘ Node =∙= g' ∘ mapL (h ∘ foldTree f g)
    c2 = 
      h ∘ foldTree f g ∘ Node
        =∙=⟨ post∘Pres=∙= h (post∘Pres=∙= g (foldTreeMap←foldTree f g)) ⟩
      h ∘ g ∘ mapL (foldTree f g)
        =∙=⟨ pre∘Pres=∙= (mapL (foldTree f g)) hgEg'mh ⟩
      g' ∘ mapL h ∘ mapL (foldTree f g)
        =∙=⟨ post∘Pres=∙= g' (mapPres∘ h (foldTree f g)) ⟩
      g' ∘ mapL (h ∘ foldTree f g)
        QED=∙=

#+end_src agda2
** Session January 10th
*** we discussed §4, in particular 
**** why Gibbons introduces comp
**** treesort = comp flatten . mkTree , Alexandra wrote down
a derivation, see [[https://timrichter.github.io/CartesianSeminar/2210/Whiteboard_CS_230110_1.jpg][Whiteboard_CS_230110_1.jpg]]
**** also compare Nicola's type analysis in [[https://timrichter.github.io/CartesianSeminar/2210/radix.dvi.pdf][radix.dvi.pdf]] 
**** discussed pre- and post-composition using a diagram for _∘_
see [[https://timrichter.github.io/CartesianSeminar/2210/Whiteboard_CS_230110_2.jpg][Whiteboard_CS_230110_2.jpg]]
**** using fusion for foldr, we derived that in order to write
treesort as foldr et ft, we need to set
  et = comp flatten Leaf
(see [[https://timrichter.github.io/CartesianSeminar/2210/Whiteboard_CS_230110_3.jpg][Whiteboard_CS_230110_3.jpg]])
**** Homework : look into the derivation of ft !
*** Code
#+begin_src agda2

-- mkTree "is" a foldr:

--   We had previously defined mkTree as follows:
--
--   mkTree : {A B : Set} → {{ FinOrd B }} → List (A → B) → List A → Tree (List A)
--   mkTree []       as = Leaf as
--   mkTree (d ∷ ds) as = Node (mapL (mkTree ds) (ptn d as))

--   Let's first define the "fm". As ptn needs the instance
--   argument {{FinOrd B}}, fm needs this as well 

fm : {A B : Set} → {{ FinOrd B }} → (A → B) → (List A → Tree(List A)) →
            List A → Tree(List A)
fm d g = Node ∘ mapL g ∘ ptn d  -- <- note that this is a funcion of type List A → Tree(List A)  !! 

mkTreeIsFoldr : {A B : Set} → {{finB : FinOrd B }} →
                mkTree {A} {B} =∙= foldr (fm {A} {B} {{finB}}) Leaf
mkTreeIsFoldr [] = refl
mkTreeIsFoldr (d ∷ ds) = 
  (λ as → Node (mapL (mkTree ds) (ptn d as)))
    =⟨ refl {- η-Rule -} ⟩
  (Node ∘ (mapL (mkTree ds)) ∘ (ptn d))
    =⟨ refl {- Def. fm -} ⟩
  fm d (mkTree ds)
    =⟨ cong (fm d) (mkTreeIsFoldr ds) ⟩
  fm d (foldr fm Leaf ds)
    QED

--   Two remarks
--   1. we had to use induction (over the first argument of type List(A → B)
--      to prove mkTreeIsFold. Thus we cannot hope to be able to prove the stronger
--         mkTree == foldr fm Leaf.
--   2. For any ds, we thus proved
--         mkTree ds == foldr fm Leaf ds
--      both sides are functions (of type List A → Tree(List A)),
--      and we proved that these not merely behave the same on any input,
--      but really are the same as λ-Terms (or as algorithms) !

-- Towards writing treesort as a foldr
--   we first define comp as a synonym for  _∘_

comp : {A B C : Set} → (B → C) → (A → B) → (A → C)
comp = _∘_

--  Now, treesort, which was defined as
--
--   treesort : {A B : Set} → {{ FinOrd B }} → List (A → B) → List A → List A
--   treesort ds as = flatten (mkTree ds as)
--
--  can be shown to be extensionally equal to  comp flatten ∘ mktree :

treesortWithComp : {A B : Set} → {{ finB : FinOrd B }} →
                   treesort {A} {B} {{finB}} =∙= comp flatten ∘ mkTree {A} {B}
treesortWithComp = refl∙

-- Note that, in fact, we can even prove the stronger

strongerTreesortWithComp : {A B : Set} → {{ finB : FinOrd B }} →
                           treesort {A} {B} {{finB}} == comp flatten ∘ mkTree {A} {B}
strongerTreesortWithComp = refl

-- i.e. both sides reduce to the same λ expression. Crucial in this is the η-rule :

strongerTreesortWithComp' : {A B : Set} → {{ finB : FinOrd B }} →
                           treesort {A} {B} {{finB}} == comp flatten ∘ mkTree {A} {B}
strongerTreesortWithComp' =  -- let's expand the steps
   treesort
     =⟨ refl {- η expansion -} ⟩
   (λ ds → treesort ds)
     =⟨ refl {- Def. treesort -} ⟩
   (λ ds → flatten ∘ mkTree ds)
     =⟨ refl {- Def. comp -} ⟩
   (λ ds → comp flatten (mkTree ds))
     =⟨ refl {- Def. _∘_ -} ⟩
   (λ ds → (comp flatten ∘ mkTree) ds)
     =⟨ refl {- η reduction -} ⟩
   (comp flatten ∘ mkTree)
     QED


#+end_src agda2
** Code from the appendices (Tim 13.01.23)
*** Appendix B

#+begin_src agda2
-- We deviate a little from the paper by defining, instead of their "Digit",
-- the type family Fin

data Fin : ℕ → Set where
  FZero : {n : ℕ} → Fin (Succ n)
  FSucc : {n : ℕ} → Fin n → Fin (Succ n)

-- thus, Fin Zero is the empty type, and Fin (Succ n) has
-- elements  FZero {n}  and  FSucc {n} i  where i : Fin n,
-- so Fin (Succ n) has exactly one nore element than Fin n.

-- We prove that Fin n is finite by constructing an element of
-- FinOrd (Fin n)

-- record FinOrd (A : Set) : Set where
--   constructor MkFinOrd
--   field
--     card : ℕ
--     allA : List A
--     each∈ : ∀ a → a ∈ allA
--     uniqueness : mapL (λ a → ∈toℕ (each∈ a)) allA == [ 1 ⋯ card ]

-- "observational" proof of list equality: two nonempty lists are equal
-- iff their heads and their tails are equal
{-
list==Obs : {A : Set} → {a b : A} → {as bs : List A} →
            a == b → as == bs → (a ∷ as) == (b ∷ bs)
list==Obs refl refl = refl

mapLComp : {A B C : Set} → (f : B → C) → (g : A → B) →
           mapL (f ∘ g) =∙= mapL f ∘ mapL g
mapLComp f g []       = refl
mapLComp f g (a ∷ as) = cong (f (g a) ∷_) (mapLComp f g as)
-}
mapLPresLength : {A B : Set} → (f : A → B) → (as : List A) →
                 length (mapL f as) == length as
mapLPresLength f [] = refl
mapLPresLength f (a ∷ as) = cong Succ (mapLPresLength f as)


finFinOrd : (n : ℕ) → FinOrd (Fin n)
finFinOrd n = MkFinOrd n (allFin n) (each∈Fin n) (uniqueFin n) where
  allFin : ∀ n → List (Fin n)
  allFin Zero     = []
  allFin (Succ n) = FZero ∷ (mapL FSucc (allFin n))
  each∈Fin : ∀ n i → i ∈ allFin n
  each∈Fin (Succ n) FZero     = Here _
  each∈Fin (Succ n) (FSucc i) = There (∈MapL FSucc (each∈Fin n i))
  uniqueFin : ∀ n → length (allFin n) == n
  uniqueFin Zero = refl
  uniqueFin (Succ n) = 
    Succ (length (mapL FSucc (allFin n)))
      =⟨ cong Succ (mapLPresLength FSucc (allFin n)) ⟩
    Succ (length (allFin n))
      =⟨ cong Succ (uniqueFin n) ⟩
    Succ n
      QED

{-  TODO

record Σ (A : Set) (P : A → Set) : Set where
   constructor _**_
   field
     pr₁ : A
     pr₂ : P pr₁



divModFam : ℕ → (m : ℕ) → Set 
divModFam x m = Σ ℕ (λ d → Σ (Fin m) λ r → x == d * m + toℕ {{finFinOrd m}} r)

divMod : (n : ℕ) → (m : ℕ) → {m' : ℕ} → {m == Succ m'} →
         divModFam n m
divMod n m = {!!}


_div_ : ℕ → (n : ℕ) → {m : ℕ} → {n == Succ m} → ℕ

_mod_ : ℕ → (n : ℕ) → {m : ℕ} → {n == Succ m} → Fin n
d mod Succ m = {!!}
-}

#+end_src agda2
